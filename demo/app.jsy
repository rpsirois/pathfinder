const goal = new Planner.Goal @
    'KillEnemy'
    , @{} kTargetIsDead: true

const actions = @[]
    new Planner.Action @
        'Attack'
        , @{} kWeaponIsLoaded: true
        , @{} kTargetIsDead: true

    , new Planner.Action @
        'LoadWeapon'
        , @{} kWeaponIsArmed: true
        , @{} kWeaponIsLoaded: true

    , new Planner.Action @
        'DrawWeapon'
        , {}
        , @{} kWeaponIsArmed: true








class GoalView extends Inferno.Component ::
    constructor( props ) ::
        super @ props
        this.state = {
            editing: false
        }

    renderBool( bool ) :: return bool ? 'true' : 'false'

    render() ::
        let conditions = Object.keys( this.props.goal.conditions ).map @ key => <li><strong>{ key }</strong>: { typeof this.props.goal.conditions[key] === 'boolean' ? this.renderBool( this.props.goal.conditions[key] ) : this.props.goal.conditions[key] }</li>
        const exitModal = () => :: this.setState @ { editing: false }
        const update = () => :: this.setState()

        return @
            <div class="card">
                <button onClick={ e => this.props.removeGoal() }>X</button>
                <button onClick={ e => this.setState( { editing: true } ) }>E</button>
                <div class="clearing"></div>
                <p>Key: <strong>{ this.props.goal.key }</strong></p>
                <p>Priority: <strong>{ this.props.goal.priority }</strong></p>
                <p>
                    Conditions:
                    <ul>{ conditions }</ul>
                </p>
                { this.state.editing ? <GoalEditor goal={ this.props.goal } exitModal={ exitModal } update={ update } /> : '' }
            </div>

class GoalEditor extends Inferno.Component ::
    constructor( props ) ::
        super @ props
        this.state = {
            c: 0
        }

    save = ( fields ) => ::
        let newConditions = {}

        for let i = 0; i <= this.state.c; i++ ::
            let key, val

            fields.forEach @ field => ::
                if field[0] == 'condition' + i + 'key' :: key = field[1]
                if field[0] == 'condition' + i + 'val' :: val = field[1]

            if typeof key !== 'undefined' :: newConditions[key] = val

        this.props.goal.conditions = newConditions
        this.props.exitModal()

    removeCondition = ( key ) => ::
        delete this.props.goal.conditions[key]
        this.props.update()

    addBlankCondition = ( e ) => ::
        this.props.goal.conditions[ 'newCondition' + (new Date()).getTime() ] = null
        this.props.update()

    render() ::
        let conditions = Object.keys( this.props.goal.conditions ).map @ ( key ) => ::
            let cn = this.state.c++
            return @
                <p>
                    <button type="button" onClick={ e => this.removeCondition( key ) }>X</button>
                    <input type="text" name={ 'condition' + cn + 'key' } placeholder="Condition Key" value={ key }></input>
                    <input type="text" name={ 'condition' + cn + 'val' } placeholder="Condition Value" value={ this.props.goal.conditions[key] }></input>
                </p>

        return @
            <div class="overlay">
                <div class="modal">
                    <div class="modal-header">
                        <div class="clearing"></div>
                        <button class="modal-close-btn" onClick={ () => this.props.exitModal() }>X</button>
                        <hr style="clear: both;" />
                    </div>
                    <div class="modal-content">
                        <label>
                            Key:
                            <input type="text" name="key" placeholder="Key" value={ this.props.goal.key }></input>
                        </label>
                        <br />
                        <label>
                            Priority:
                            <input type="number" min="0" step="1" name="priority" placeholder="Priority" value={ this.props.goal.priority }></input>
                        </label>
                        <p>Conditions:</p>
                        <form class="goalEditorForm" onSubmit={ e => { e.preventDefault(), this.save( Array.from( new FormData( e.target ) ) ) } } >
                            { conditions }
                        </form>
                        <button onClick={ this.addBlankCondition }>Add New Condition</button>
                    </div>
                    <div class="modal-footer">
                        <hr />
                        <button onClick={ this.close }>Cancel</button>
                        <button onClick={ e => document.getElementsByClassName( 'goalEditorForm' )[0].dispatchEvent( new CustomEvent('submit', {bubbles: true, cancelable: true}) ) }>Save</button>
                    </div>
                </div>
            </div>


class ActionView extends Inferno.Component ::
    constructor( props ) :: super @ props

    renderBool( bool ) :: return bool ? 'true' : 'false'

    render() ::
        let conditions = Object.keys( this.props.action.conditions ).map @ key => <li><strong>{ key }</strong>: { this.renderBool( this.props.action.conditions[key] ) }</li>
        let effects = Object.keys( this.props.action.effects ).map @ key => <li><strong>{ key }</strong>: { this.renderBool( this.props.action.effects[key] ) }</li>

        return @
            <div class="card">
                <button onClick={ e => this.props.removeAction() }>X</button>
                <div class="clearing"></div>
                <p>Key: <strong>{ this.props.action.key }</strong></p>
                <p>
                    Conditions:
                    <ul>{ conditions }</ul>
                    Effects:
                    <ul>{ effects }</ul>
                </p>
            </div>

class PlanCrumbView extends Inferno.Component ::
    constructor( props ) :: super @ props

    render() :: return @ <li class="plancrumb">{ this.props.crumb }</li>

class PlanView extends Inferno.Component ::
    constructor( props ) :: super @ props

    render() ::
        if this.plan && this.props.plan.crumbs.length ::
            let crumbs = this.props.plan.crumbs.map @ crumb => <PlanCrumbView crumb={ crumb.key } />

            return @
                <div>
                    <p>Zee plan to <strong>{ this.props.plan.goal.key }</strong>:</p>
                    <ol>{ crumbs }</ol>
                </div>
        else ::
            return @ <p>No result.</p>

class App extends Inferno.Component ::
    constructor( props ) ::
        super @ props

        let agent = new Planner.Agent()

        agent.goals.push @ goal.clone()
        actions.forEach @ action => agent.addAction @ action.clone()

        this.state = ::
            agent: agent
            , plan: agent.getPlan()

    removeGoal( aGoal ) ::
        this.state.agent.goals.remove @ aGoal
        this.setState @ { plan: this.state.agent.getPlan() }

    removeAction( anAction ) ::
        this.state.agent.removeAction @ anAction
        this.setState @ { plan: this.state.agent.getPlan() }

    render() ::
        const actions = this.state.agent.actions.map @ action =>
            <ActionView key={ action.key } action={ action } removeAction={ () => this.removeAction( action ) } />

        const goals = this.state.agent.goals.contents.map @ goal =>
            <GoalView key={ goal.key } goal={ goal } removeGoal={ () => this.removeGoal( goal ) } />

        return @
            <div>
                <p>Zee goalz:</p>
                { goals }
                <p>Zee akshunz:</p>
                { actions }
                <PlanView plan={ this.state.plan } />
            </div>

let container = document.getElementById @ 'container'

Inferno.render @ <App />, container
