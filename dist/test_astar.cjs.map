{"version":3,"file":"test_astar.cjs","sources":["../code/heap.jsy","../code/astar.jsy","../code/test_astar.jsy"],"sourcesContent":["function defaultScoreFn( x ) :: return x\nfunction defaultCompareFn( a, b ) :: return a < b\n\nexport class Heap ::\n    constructor( scoreFn=defaultScoreFn, compareFn=defaultCompareFn ) ::\n        this.contents = []\n        this.scoreFn = scoreFn\n        this.compareFn = compareFn\n\n    toString() ::\n        return this.contents\n\n    size() ::\n        return this.contents.length\n\n    contains( item ) ::\n        return this.contents.indexOf( item ) >= 0\n\n    peek() ::\n        return this.contents[0]\n\n    remove( node ) ::\n        const next = ( idx ) => ::\n            if this.size() == 0 :: return null\n\n            if this.contents[idx] == node ::\n                let endNode = this.contents.pop()\n                if node === endNode ::\n                    return node\n                else ::\n                    this.contents[idx] = endNode\n                    this.bubbleUp @ idx\n                    this.sinkDown @ idx\n                    return node\n            else\n                if this.size() - 1 == idx ::\n                    return null\n                else ::\n                    return next @ idx + 1\n\n        return next @ 0\n\n    push( nodes ) ::\n        console.log @ 'push'\n        if !Array.isArray @ nodes ::\n            nodes = @# nodes\n\n        nodes.forEach @\\ node => ::\n            this.contents.push @ node\n            this.bubbleUp @ this.size() - 1\n\n        return nodes\n\n    pop() ::\n        console.log @ 'pop'\n        let result = this.contents[0]\n        let end = this.contents.pop()\n\n        if this.size() > 0 ::\n            this.contents[0] = end\n            this.sinkDown @ 0\n\n        return result\n\n    swap( a, b ) ::\n        const t = this.contents[a]\n\n        this.contents[a] = this.contents[b]\n        this.contents[b] = t\n\n        return a\n\n    getIndexScore( index ) ::\n        return this.scoreFn @ this.contents[index]\n\n    getParentIndex( index ) ::\n        return Math.floor @ (index - 1) / 2\n\n    bubbleUp( index ) ::\n        if index > 0 ::\n            const parentIndex = this.getParentIndex @ index\n\n            if this.compareFn @ this.getIndexScore( index ), this.getIndexScore( parentIndex ) ::\n                this.bubbleUp @ this.swap @ parentIndex, index\n\n    sinkDown( parentIndex ) ::\n        if parentIndex < this.size() ::\n            const parentScore = this.getIndexScore @ parentIndex\n            const rightIndex = parentIndex * 2 + 2\n            const leftIndex = parentIndex * 2 + 1\n            let swapIdx\n\n            const leftIndexScore = this.getIndexScore @ leftIndex\n\n            if leftIndex < this.size() ::\n                if this.compareFn @ leftIndexScore, parentScore ::\n                    swapIdx = leftIndex\n            \n            if rightIndex < this.size() ::\n                const rightIndexScore = this.getIndexScore @ rightIndex\n\n                if this.compareFn @ rightIndexScore, ( swapIdx !== undefined ? leftIndexScore : parentScore ) ::\n                    swapIdx = rightIndex\n\n            if swapIdx !== undefined ::\n                this.sinkDown @ this.swap @ swapIdx, parentIndex\n","import { Heap } from './heap.jsy'\n\nexport class AStar ::\n    constructor( heurFn, goalFn, succFn, costFn ) ::\n        this.heurFn = heurFn\n        this.goalFn = goalFn\n        this.succFn = succFn\n        this.costFn = costFn\n\n    _nodeify( data, prev=null ) ::\n        data._astar_data = @{}\n            g: this.costFn @ data\n            h: this.heurFn @ data, this.start\n            prev\n\n        return data\n\n    _step() ::\n        let current = this.open.pop()\n        this.closed.push @ current\n\n        if this.goalFn @ current :: return this.traceback @ current\n\n        this.succFn( current ).forEach @\\ successor ::\n            if this.closed.indexOf( successor ) < 0 ::\n                if this.open.contains @ successor ::\n                    let tempCost = current._astar_data.g + successor._astar_data.g\n\n                    if tempCost < successor._astar_data.g ::\n                        successor._astar_data.g = tempCost\n                        successor._astar_data.prev = current\n                else ::\n                    this.open.push @ this._nodeify @ successor, current\n\n        if this.open.size() == 0 :: return []\n\n        return this._step()\n\n    find( start ) ::\n        this.start = start\n        this.open = new Heap @\\ node :: return node._astar_data.g + node._astar_data.h\n        this.closed = []\n\n        this.open.push @ this._nodeify @ this.start\n\n        return this._step()\n        \n    traceback( goal ) ::\n        let path = @# goal\n        let trace = @\\ node ::\n            if node._astar_data.prev ::\n                path.push @ node._astar_data.prev\n                trace @ node._astar_data.prev\n\n        trace @ goal\n        path.reverse()\n\n        return path.map @\\ node ::\n            delete node._astar_data\n            return node\n","import { AStar } from './astar.jsy'\n\nlet start = @{}\n    name: 'start'\n    weight: 0\n    isGoal: false\n    edges: []\n\nlet pathA1 = @{}\n    name: 'A1'\n    weight: 2\n    isGoal: false\n    edges: []\n\nlet pathA2 = @{}\n    name: 'A2'\n    weight: 10\n    isGoal: false\n    edges: []\n\nlet pathA3 = @{}\n    name: 'A3'\n    weight: 1\n    isGoal: false\n    edges: []\n\nlet pathB1 = @{}\n    name: 'B1'\n    weight: 1\n    isGoal: false\n    edges: []\n\nlet pathB2 = @{}\n    name: 'B2'\n    weight: 1\n    isGoal: false\n    edges: []\n\nlet pathB3 = @{}\n    name: 'B3'\n    weight: 12\n    isGoal: false\n    edges: []\n\nlet goal = @{}\n    name: 'goal'\n    weight: 0\n    isGoal: true\n    edges: []\n\nstart.edges = @# pathA1, pathB1\npathA1.edges = @# start, pathA2\npathA2.edges = @# pathA1, pathA3, pathB2\npathA3.edges = @# pathA2, goal\npathB1.edges = @# start, pathB2\npathB2.edges = @# pathB1, pathB3, pathA2\npathB3.edges = @# pathB2, goal\ngoal.edges = @# pathA3, pathB3\n\nconst heurFn = @\\ node, start :: return 1\nconst goalFn = @\\ node :: return node.isGoal\nconst succFn = @\\ node :: return node.edges\nconst costFn = @\\ node :: return node.weight\n\nlet pathfinder = new AStar @ heurFn, goalFn, succFn, costFn\n\nconsole.log @ pathfinder.find @ start\n"],"names":[],"mappings":";;AAAA,8BAA+B;AAC/B,mCAAoC;;;IAGhC;QACI;QACA;QACA;;IAEJ;QACI;;IAEJ;QACI;;IAEJ;QACI;;IAEJ;QACI;;IAEJ;QACI;gBACM,mBAAoB;;gBAEpB;gBACE;oBACE;oBACE;;oBAEA;oBACA,cAAe;oBACf,cAAe;oBACf;;oBAEF;oBACE;;oBAEA,YAAa;;QAEzB,YAAa;;IAEjB;QACI,YAAa;YACV,eAAgB;YACf,SAAU;;QAEd;YACI,mBAAoB;YACpB,cAAe;;QAEnB;;IAEJ;QACI,YAAa;QACb;QACA;;YAEE;YACE;YACA,cAAe;;QAEnB;;IAEJ;QACI;;QAEA;QACA;;QAEA;;IAEJ;QACI,oBAAqB;;IAEzB;QACI,kBAAmB;;IAEvB;YACM;YACE,wCAAyC;;gBAEvC,eAAiB;gBACf,cAAe,UAAY;;IAEvC;YACM;YACE,uCAAwC;YACxC;YACA;YACA;;YAEA,0CAA2C;;gBAEzC;oBACI,eAAiB;oBACf;;gBAEN;gBACE,2CAA4C;;oBAE1C,eAAiB;oBACf;;gBAEN;gBACE,cAAe,UAAY;;;ICtGvC;QACI;QACA;QACA;QACA;;IAEJ;QACI;YACI,eAAgB;YAChB,eAAgB;YAChB;;QAEJ;;IAEJ;QACI;QACA,iBAAkB;;YAEhB,YAAc,YAAW,sBAAwB;;QAEnD;gBACM;oBACI,mBAAqB;oBACnB;;wBAEE;wBACE;wBACA;;oBAEJ,eAAgB,cAAgB;;YAE1C,wBAAyB;;QAE3B;;IAEJ;QACI;QACA;QACA;;QAEA,eAAgB,cAAgB;;QAEhC;;IAEJ;QACI,YAAa;QACb;gBACM;gBACE,UAAW;gBACX,MAAO;;QAEf,MAAO;QACP;;QAEA;YACI;YACA;;ACzDZ;IACI,MAAM;IACN;IACA;IACA;;AAEJ;IACI,MAAM;IACN;IACA;IACA;;AAEJ;IACI,MAAM;IACN;IACA;IACA;;AAEJ;IACI,MAAM;IACN;IACA;IACA;;AAEJ;IACI,MAAM;IACN;IACA;IACA;;AAEJ;IACI,MAAM;IACN;IACA;IACA;;AAEJ;IACI,MAAM;IACN;IACA;IACA;;AAEJ;IACI,MAAM;IACN;IACA;IACA;;AAEJ,eAAgB;AAChB,gBAAiB;AACjB,gBAAiB;AACjB,gBAAiB;AACjB,gBAAiB;AACjB,gBAAiB;AACjB,gBAAiB;AACjB,cAAe;;AAEf;AACA;AACA;AACA;;AAEA,2BAA4B;;AAE5B,YAAa,gBAAkB"}