{"version":3,"file":"test_goap.cjs","sources":["../code/heap.jsy","../code/astar.jsy","../code/planner.jsy","../code/test_goap.jsy"],"sourcesContent":["function defaultScoreFn( x ) :: return x\nfunction defaultCompareFn( a, b ) :: return a < b\n\nexport class Heap ::\n    constructor( scoreFn=defaultScoreFn, compareFn=defaultCompareFn ) ::\n        this.contents = []\n        this.scoreFn = scoreFn\n        this.compareFn = compareFn\n\n    toString() ::\n        return this.contents\n\n    size() ::\n        return this.contents.length\n\n    contains( item ) ::\n        return this.contents.indexOf( item ) >= 0\n\n    peek() ::\n        return this.contents[0]\n\n    remove( node ) ::\n        const next = ( idx ) => ::\n            if this.size() == 0 :: return null\n\n            if this.contents[idx] == node ::\n                let endNode = this.contents.pop()\n                if node === endNode ::\n                    return node\n                else ::\n                    this.contents[idx] = endNode\n                    this.bubbleUp @ idx\n                    this.sinkDown @ idx\n                    return node\n            else\n                if this.size() - 1 == idx ::\n                    return null\n                else ::\n                    return next @ idx + 1\n\n        return next @ 0\n\n    push( nodes ) ::\n        console.log @ 'push'\n        if !Array.isArray @ nodes ::\n            nodes = @# nodes\n\n        nodes.forEach @\\ node => ::\n            this.contents.push @ node\n            this.bubbleUp @ this.size() - 1\n\n        return nodes\n\n    pop() ::\n        console.log @ 'pop'\n        let result = this.contents[0]\n        let end = this.contents.pop()\n\n        if this.size() > 0 ::\n            this.contents[0] = end\n            this.sinkDown @ 0\n\n        return result\n\n    swap( a, b ) ::\n        const t = this.contents[a]\n\n        this.contents[a] = this.contents[b]\n        this.contents[b] = t\n\n        return a\n\n    getIndexScore( index ) ::\n        return this.scoreFn @ this.contents[index]\n\n    getParentIndex( index ) ::\n        return Math.floor @ (index - 1) / 2\n\n    bubbleUp( index ) ::\n        if index > 0 ::\n            const parentIndex = this.getParentIndex @ index\n\n            if this.compareFn @ this.getIndexScore( index ), this.getIndexScore( parentIndex ) ::\n                this.bubbleUp @ this.swap @ parentIndex, index\n\n    sinkDown( parentIndex ) ::\n        if parentIndex < this.size() ::\n            const parentScore = this.getIndexScore @ parentIndex\n            const rightIndex = parentIndex * 2 + 2\n            const leftIndex = parentIndex * 2 + 1\n            let swapIdx\n\n            const leftIndexScore = this.getIndexScore @ leftIndex\n\n            if leftIndex < this.size() ::\n                if this.compareFn @ leftIndexScore, parentScore ::\n                    swapIdx = leftIndex\n            \n            if rightIndex < this.size() ::\n                const rightIndexScore = this.getIndexScore @ rightIndex\n\n                if this.compareFn @ rightIndexScore, ( swapIdx !== undefined ? leftIndexScore : parentScore ) ::\n                    swapIdx = rightIndex\n\n            if swapIdx !== undefined ::\n                this.sinkDown @ this.swap @ swapIdx, parentIndex\n","import { Heap } from './heap.jsy'\n\nexport class AStar ::\n    constructor( heurFn, goalFn, succFn, costFn ) ::\n        this.heurFn = heurFn\n        this.goalFn = goalFn\n        this.succFn = succFn\n        this.costFn = costFn\n\n    _nodeify( data, prev=null ) ::\n        data._astar_data = @{}\n            g: this.costFn @ data\n            h: this.heurFn @ data, this.start\n            prev\n\n        return data\n\n    _step() ::\n        let current = this.open.pop()\n        this.closed.push @ current\n\n        if this.goalFn @ current :: return this.traceback @ current\n\n        this.succFn( current ).forEach @\\ successor ::\n            if this.closed.indexOf( successor ) < 0 ::\n                if this.open.contains @ successor ::\n                    let tempCost = current._astar_data.g + successor._astar_data.g\n\n                    if tempCost < successor._astar_data.g ::\n                        successor._astar_data.g = tempCost\n                        successor._astar_data.prev = current\n                else ::\n                    this.open.push @ this._nodeify @ successor, current\n\n        if this.open.size() == 0 :: return []\n\n        return this._step()\n\n    find( start ) ::\n        this.start = start\n        this.open = new Heap @\\ node :: return node._astar_data.g + node._astar_data.h\n        this.closed = []\n\n        this.open.push @ this._nodeify @ this.start\n\n        return this._step()\n        \n    traceback( goal ) ::\n        let path = @# goal\n        let trace = @\\ node ::\n            if node._astar_data.prev ::\n                path.push @ node._astar_data.prev\n                trace @ node._astar_data.prev\n\n        trace @ goal\n        path.reverse()\n\n        return path.map @\\ node ::\n            delete node._astar_data\n            return node\n","import { AStar } from './astar.jsy'\nimport { Heap } from './heap.jsy'\n\n\nexport class GOAP ::\n    constructor( agent ) ::\n        this.agent = agent\n\n    formulate() ::\n        let goal = this.agent.getGoal()\n\n        if typeof goal === 'undefined' :: return []\n\n        let finalActions = []\n\n        console.log @ `Formulating plan for ${ goal }.`\n\n        // TODO allow for composite of actions to accomplish goal\n        this.agent.actions.forEach @\\ action ::\n            if action.satisfies @ goal ::\n                finalActions.push @ action\n\n        if finalActions.length === 0 :: return []\n\n        let heurFn = @\\ node, root :: return 0\n        let goalFn = @\\ node :: return this.agent.stateSatisfies @ node\n        let succFn = @\\ node :: return node.chain\n        let costFn = @\\ node :: return node.cost\n\n        console.log @ `Starting search with action ${ finalActions[0] }.`\n\n        let planner = new AStar @ heurFn, goalFn, succFn, costFn\n        let path = planner.find @ finalActions.pop()\n        path.reverse()\n\n        if path.length === 0 ::\n            console.log @ 'No plan found!'\n        else ::\n            console.log @ 'Plan:'\n            path.forEach @ action => console.log @ `\\t${ action }`\n\n        return @{} goal, path \n\n\nexport class Agent ::\n    constructor() ::\n        this.planner = new GOAP @ this\n        this.goals = new Heap()\n        this.actions = []\n        this.state = {}\n\n    getGoal() ::\n        return this.goals.peek()\n\n    addAction( anAction ) ::\n        this.actions.forEach @\\ action ::\n            if anAction.satisfies @ action :: action.chain.push @ anAction\n\n            if action.satisfies @ anAction :: anAction.chain.push @ action\n\n        this.actions.push @ anAction\n\n        return anAction\n\n    removeAction( anAction ) ::\n        this.actions = this.actions.filter @\\ ea :: return anAction !== ea\n        this.actions.forEach @\\ action :: action.chain = action.chain.filter @\\ ea :: return anAction !== ea\n\n        return anAction\n\n    stateSatisfies( anIntermediateState ) ::\n        let targetState = anIntermediateState.conditions\n\n        for let tsKey in targetState ::\n            let tsValue = targetState[tsKey]\n\n            if this.state[tsKey] != tsValue :: return false\n\n        return true\n\n    getPlan() :: return this.planner.formulate()\n        \n\n\nclass IntermediateState ::\n    constructor( key, conditions={} ) ::\n        this.key = key\n        this.conditions = conditions\n\n    toString() :: return this.key\n\n    satisfies( anIntermediateState ) :: return new Error @ 'An IntermediateState must implement @satisfies( anIntermediateState ).'\n\n    clone() :: return new Error @ 'An IntermediateState must implement @clone().'\n\n\nexport class Action extends IntermediateState ::\n    constructor( key, conditions={}, effects={}, cost=0 ) ::\n        super @ key, conditions\n        this.effects = effects\n        this.cost = cost\n        this.chain = []\n\n    satisfies( anIntermediateState ) ::\n        let state = anIntermediateState.conditions\n        \n        for let eKey in this.effects ::\n            let eVal = this.effects[eKey]\n\n            for let sKey in state ::\n                let sVal = state[sKey]\n\n                if eKey == sKey && eVal == sVal :: return true\n\n        return false\n\n    clone() :: return Object.assign @ new Action(), this\n\n\nexport class Goal extends IntermediateState ::\n    constructor( key, conditions={}, priority=0 ) ::\n        super @ key, conditions\n        this.priority = priority\n\n    clone() :: return Object.assign @ new Goal(), this\n","import { GOAP, Goal, Action, Agent } from './planner.jsy'\n\nlet goal = new Goal @ 'KillEnemy', @{}\n    kTargetIsDead: true\n\nlet actions = @#\n    new Action @\n        'Attack'\n        @{} kWeaponIsLoaded: true\n        @{} kTargetIsDead: true\n\n    new Action @\n        'LoadWeapon'\n        @{} kWeaponIsArmed: true\n        @{} kWeaponIsLoaded: true\n\n    new Action @\n        'DrawWeapon'\n        {}\n        @{} kWeaponIsArmed: true\n\nlet agent = new Agent()\n\nagent.goals.push @ goal.clone()\n\nactions.forEach @\\ action :: return agent.addAction @ action.clone()\n\nagent.getPlan()\n"],"names":[],"mappings":";;AAAA,8BAA+B;AAC/B,mCAAoC;;;IAGhC;QACI;QACA;QACA;;IAEJ;QACI;;IAEJ;QACI;;IAEJ;QACI;;IAEJ;QACI;;IAEJ;QACI;gBACM,mBAAoB;;gBAEpB;gBACE;oBACE;oBACE;;oBAEA;oBACA,cAAe;oBACf,cAAe;oBACf;;oBAEF;oBACE;;oBAEA,YAAa;;QAEzB,YAAa;;IAEjB;QACI,YAAa;YACV,eAAgB;YACf,SAAU;;QAEd;YACI,mBAAoB;YACpB,cAAe;;QAEnB;;IAEJ;QACI,YAAa;QACb;QACA;;YAEE;YACE;YACA,cAAe;;QAEnB;;IAEJ;QACI;;QAEA;QACA;;QAEA;;IAEJ;QACI,oBAAqB;;IAEzB;QACI,kBAAmB;;IAEvB;YACM;YACE,wCAAyC;;gBAEvC,eAAiB;gBACf,cAAe,UAAY;;IAEvC;YACM;YACE,uCAAwC;YACxC;YACA;YACA;;YAEA,0CAA2C;;gBAEzC;oBACI,eAAiB;oBACf;;gBAEN;gBACE,2CAA4C;;oBAE1C,eAAiB;oBACf;;gBAEN;gBACE,cAAe,UAAY;;;ICtGvC;QACI;QACA;QACA;QACA;;IAEJ;QACI;YACI,eAAgB;YAChB,eAAgB;YAChB;;QAEJ;;IAEJ;QACI;QACA,iBAAkB;;YAEhB,YAAc,YAAW,sBAAwB;;QAEnD;gBACM;oBACI,mBAAqB;oBACnB;;wBAEE;wBACE;wBACA;;oBAEJ,eAAgB,cAAgB;;YAE1C,wBAAyB;;QAE3B;;IAEJ;QACI;QACA;QACA;;QAEA,eAAgB,cAAgB;;QAEhC;;IAEJ;QACI,YAAa;QACb;gBACM;gBACE,UAAW;gBACX,MAAO;;QAEf,MAAO;QACP;;QAEA;YACI;YACA;;;ICtDR;QACI;;IAEJ;QACI;;YAEE,gBAAiB,cAAc;;QAEjC;;QAEA,YAAc,+BAA+B;;;QAG7C;gBACM,iBAAmB;gBACjB,kBAAmB;;YAEzB,4BAA6B;;QAE/B;QACA,6DAA0D;QAC1D;QACA;;QAEA,YAAc,iDAAiD;;QAE/D,wBAAyB;QACzB,wBAAyB;QACzB;;YAEE;YACE,YAAa;;YAEb,YAAa;YACb,aAAc,sBAAwB,cAAe;;QAEzD,QAAU;;;AAGlB;IACI;QACI,wBAAyB;QACzB;QACA;QACA;;IAEJ;QACI;;IAEJ;QACI;gBACM,mBAAqB,WAAU,kBAAoB;;gBAEnD,iBAAmB,aAAY,oBAAsB;;QAE3D,kBAAmB;;QAEnB;;IAEJ;QACI;QACA;;QAEA;;IAEJ;QACI;;aAEG;YACC;;gBAEE,+BAAgC;;QAEtC;;IAEJ,WAAY;;;;AAIhB;IACI;QACI;QACA;;IAEJ,YAAa;;IAEb,kCAAmC,iBAAmB;;IAEtD,SAAU,iBAAmB;;;AAGjC;IACI;QACI,MAAO;QACP;QACA;QACA;;IAEJ;QACI;;aAEG;YACC;;iBAEG;gBACC;;oBAEE,+BAAgC;;QAE1C;;IAEJ,SAAU,qBAAuB;;;AAGrC;IACI;QACI,MAAO;QACP;;IAEJ,SAAU,qBAAuB;;AC1HrC,oBAAqB,WAAY;IAC7B;;AAEJ;IACI;QACI;SACG;SACA;;IAEP;QACI;SACG;SACA;;IAEP;QACI;QACA;SACG;;AAEX;;AAEA,iBAAkB;;AAElB,wDAAqD;;AAErD"}